// kitsune.pest
// This file defines the grammar for the Kitsune language using Pest's PEG syntax.

// Whitespace and comments are automatically skipped by default if defined.
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

// Keywords are defined as distinct rules for clarity and matching.
// The '@' makes these atomic, preventing them from being broken down further.
LET = @{ "let" }
CONST = @{ "const" }
STATIC = @{ "static" }
FN = @{ "fn" }
IF = @{ "if" }
ELSE = @{ "else" }
ELIF = @{ "elif" }
MATCH = @{ "match" }
WHILE = @{ "while" }
FOR = @{ "for" }
IN = @{ "in" }
PUB = @{ "pub" }
RETURN = @{ "return" }
TRUE = @{ "true" }
FALSE = @{ "false" }

// Symbols and operators.
L_BRACE = @{ "{" }
R_BRACE = @{ "}" }
L_PAREN = @{ "(" }
R_PAREN = @{ ")" }
L_BRACKET = @{ "[" }
R_BRACKET = @{ "]" }
COMMA = @{ "," }
RANGE_INCLUSIVE = @{ "..=" }
RANGE = @{ ".." }
EQ = @{ "=" }
SEMICOLON = @{ ";" }
STAR = @{ "*" }
SLASH = @{ "/" }
PLUS = @{ "+" }
MINUS = @{ "-" }
COLON = @{ ":" }
ARROW = @{ "->" }

// Assignment Operators
ADD_ASSIGN = @{ "+=" }
SUB_ASSIGN = @{ "-=" }
MUL_ASSIGN = @{ "*=" }
DIV_ASSIGN = @{ "/=" }
MOD_ASSIGN = @{ "%=" }
BIT_AND_ASSIGN = @{ "&=" }
BIT_OR_ASSIGN = @{ "|=" }
BIT_XOR_ASSIGN = @{ "^=" }
SHL_ASSIGN = @{ "<<=" }
SHR_ASSIGN = @{ ">>=" }

// Logical Operators
BANG = @{ "!" }
AND = @{ "&&" }
OR = @{ "||" }

// Bitwise Operators
BIT_AND = @{ "&" }
BIT_OR = @{ "|" }
BIT_XOR = @{ "^" }
SHL = @{ "<<" }
SHR = @{ ">>" }

// Comparison Operators
EQ_EQ = @{ "==" }
NOT_EQ = @{ "!=" }
LT_EQ = @{ "<=" }
GT_EQ = @{ ">=" }
LT = @{ "<" }
GT = @{ ">" }

// Literals and identifiers. The `@` makes these atomic, preventing them from being broken down further.
identifier = @{ ('a'..='z' | 'A'..='Z' | '_') ~ ('a'..='z' | 'A'..='Z' | '0'..='9' | '_')* }
integer_literal = @{ ('0'..'9')+ }
float_literal = @{ ('0'..'9')+ ~ "." ~ ('0'..'9')* }
string_literal = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

// The main entry point for parsing a Kitsune script.
// `statement*` means zero or more statements. `EOI` ensures the entire input is consumed.
kitsune_script = { statement* ~ EOI }

// Defines the various types of statements.
statement = {
    let_statement
    | const_statement
    | static_statement
    | function_statement
    | for_statement
    | while_statement
    | return_statement
    | assignment_statement
    | compound_assignment_statement
    | expression_statement
}

// Statement rule definitions.
let_statement = { LET ~ identifier ~ type_annotation? ~ EQ ~ expression ~ SEMICOLON }
const_statement = { PUB? ~ CONST ~ identifier ~ type_annotation? ~ EQ ~ expression ~ SEMICOLON }
static_statement = { PUB? ~ STATIC ~ identifier ~ type_annotation? ~ EQ ~ expression ~ SEMICOLON }

function_statement = { PUB? ~ FN ~ identifier ~ L_PAREN ~ parameter_list? ~ R_PAREN ~ return_type? ~ block }
for_statement = { FOR ~ identifier ~ IN ~ expression ~ block }
while_statement = { WHILE ~ expression ~ block }
return_statement = { RETURN ~ expression? ~ SEMICOLON }
assignment_statement = { identifier ~ EQ ~ expression ~ SEMICOLON }
compound_assignment_statement = { identifier ~ compound_assign_operator ~ expression ~ SEMICOLON }
expression_statement = { expression ~ SEMICOLON }

// Defines the different compound assignment operators.
compound_assign_operator = {
    ADD_ASSIGN | SUB_ASSIGN | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN
    | BIT_AND_ASSIGN | BIT_OR_ASSIGN | BIT_XOR_ASSIGN | SHL_ASSIGN | SHR_ASSIGN
}

// A block of statements enclosed in curly braces.
block = { L_BRACE ~ statement* ~ R_BRACE }

// A list of parameters for functions.
parameter_list = { parameter ~ (COMMA ~ parameter)* }
parameter = { identifier ~ (COLON ~ type_expr)? }

// Type annotation (e.g., `: int`).
type_annotation = { COLON ~ type_expr }
// Type expression (e.g., `int`, `Array<string>`).
type_expr = { identifier ~ (LT ~ type_expr_array ~ GT)? }
// A list of type expressions for generic types.
type_expr_array = { type_expr ~ (COMMA ~ type_expr)* }

// Return type annotation for functions (e.g., `-> int`).
return_type = { ARROW ~ identifier }

// Defines expressions with operator precedence using Pest's `precedence!` macro.
// Rules are listed from lowest precedence to highest.
expression = { precedence! {
    // Range operators (lowest precedence)
    { expression ~ (RANGE_INCLUSIVE | RANGE) ~ expression } as range_expression
    // Logical OR
    { expression ~ OR ~ expression } as logical_or_expression
    // Logical AND
    { expression ~ AND ~ expression } as logical_and_expression
    // Bitwise OR
    { expression ~ BIT_OR ~ expression } as bit_or_expression
    // Bitwise XOR
    { expression ~ BIT_XOR ~ expression } as bit_xor_expression
    // Bitwise AND
    { expression ~ BIT_AND ~ expression } as bit_and_expression
    // Comparison operators
    { expression ~ (EQ_EQ | NOT_EQ | LT_EQ | GT_EQ | LT | GT) ~ expression } as comparison_expression
    // Bit Shift operators
    { expression ~ (SHL | SHR) ~ expression } as bit_shift_expression
    // Additive operators
    { expression ~ (PLUS | MINUS) ~ expression } as additive_expression
    // Multiplicative operators
    { expression ~ (STAR | SLASH) ~ expression } as multiplicative_expression
    // Unary operators (highest precedence, right-associative)
    (MINUS | PLUS | BANG) ~ expression as unary_expression
    // Base case: Term (non-operator expressions)
    | term
}}

// Defines the basic "terms" of expressions, which don't involve operators.
term = {
    integer_literal
    | float_literal
    | string_literal
    | TRUE
    | FALSE
    | L_BRACKET ~ argument_list? ~ R_BRACKET as array_literal // Array literal (e.g., `[1, 2]`)
    | identifier ~ L_PAREN ~ argument_list? ~ R_PAREN as function_call // Function call (e.g., `func(x)`)
    | identifier // Variable reference
    | L_PAREN ~ expression ~ R_PAREN as paren_expression // Parenthesized expression (e.g., `(1 + 2)`)
    | block as block_expression // Block expression (e.g., `{ let x = 1; x + 2 }`)
}

// A list of arguments passed to functions or used in array literals.
argument_list = { expression ~ (COMMA ~ expression)* }